# UI Semantic Patch 技术实现文档

> 版本: 3.3 | 更新日期: 2026-02-09

## 1. 项目概述

### 1.1 设计目标

**UI Semantic Patch** 是一个 UI 异常场景自动生成框架，采用 **"逻辑层修改 + 物理层绘制"** 的解耦设计。核心创新在于：

1. **精准检测**: 使用 OmniParser (YOLO + PaddleOCR + Florence2) 获取像素级 UI 边界
2. **语义理解**: VLM 进行高级语义过滤，合并/清理不合理的检测结果
3. **可控生成**: 结合 meta.json 模板驱动 + VLM 内容生成 + PIL/AI 渲染

**相比端到端图像生成的优势**：
- 文字清晰度更高（PIL 精确绘制 vs AI 模糊文字）
- 样式可控性强（通过 meta.json 精确控制）
- 组件定位精准（基于 UI-JSON 坐标而非猜测）

### 1.2 整体架构

```
┌─────────────────────────────────────────────────────────────────┐
│                      run_pipeline.py (入口)                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────────┐   ┌──────────────┐   ┌──────────────────────┐│
│  │   Stage 1    │ → │   Stage 2    │ → │       Stage 3        ││
│  │  OmniParser  │   │  VLM 过滤    │   │   异常场景渲染       ││
│  │   粗检测     │   │  语义清理    │   │                      ││
│  └──────────────┘   └──────────────┘   │  ┌────────────────┐  ││
│        ↓                   ↓           │  │ dialog 模式    │  ││
│   原始 UI-JSON       清理后 UI-JSON   │  │ (弹窗覆盖)     │  ││
│   (57个组件)         (13个组件)       │  ├────────────────┤  ││
│                                        │  │ area_loading   │  ││
│                                        │  │ (区域加载)     │  ││
│                                        │  ├────────────────┤  ││
│                                        │  │content_duplicate│ ││
│                                        │  │ (内容重复)     │  ││
│                                        │  └────────────────┘  ││
│                                        └──────────────────────┘│
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. 命令行参数配置

### 2.1 完整参数列表

```bash
python run_pipeline.py [参数]
```

| 参数 | 类型 | 必需 | 默认值 | 说明 |
|------|------|------|--------|------|
| `--screenshot`, `-s` | str | ✅ | - | 原始截图路径 |
| `--instruction`, `-i` | str | ✅ | - | 异常指令描述 |
| `--output`, `-o` | str | ❌ | `./output` | 输出目录 |
| `--api-key` | str | ❌ | 环境变量 | VLM API 密钥 |
| `--api-url` | str | ❌ | OpenAI 兼容 | VLM API 端点 |
| `--structure-model` | str | ❌ | `qwen-vl-max` | Stage 2 语义过滤模型 |
| `--vlm-api-url` | str | ❌ | 同 api-url | Stage 3 VLM 端点 |
| `--vlm-model` | str | ❌ | `gpt-4o` | Stage 3 VLM 模型 |
| `--anomaly-mode` | choice | ❌ | `dialog` | 异常模式 |
| `--gt-category` | str | ❌ | - | GT 模板类别 |
| `--gt-sample` | str | ❌ | - | GT 模板样本名 |
| `--gt-dir` | str | ❌ | 自动检测 | GT 模板目录 |
| `--reference`, `-r` | str | ❌ | - | 参考弹窗图片 (dialog) |
| `--reference-icon` | str | ❌ | - | 参考加载图标 (area_loading) |
| `--target-component` | str | ❌ | - | 目标组件 ID (area_loading) |
| `--omni-device` | str | ❌ | `auto` | OmniParser 设备 |
| `--no-visualize` | flag | ❌ | False | 禁用检测可视化 |

### 2.2 异常模式说明

| 模式 | 值 | 用途 | 示例场景 |
|------|-----|------|----------|
| 弹窗覆盖 | `dialog` | 全屏/局部弹窗遮挡 | 广告弹窗、权限请求、优惠券 |
| 区域加载 | `area_loading` | 列表/组件加载状态 | 网络超时、内容加载中 |
| 内容重复 | `content_duplicate` | UI 元素重复显示 | 选集列表重复、筛选器重复 |

### 2.3 环境变量配置

```bash
# .env 文件
VLM_API_KEY=sk-xxx           # VLM API 密钥（必需）
VLM_API_URL=https://...      # VLM API 端点
VLM_MODEL=gpt-4o             # VLM 模型名称
STRUCTURE_MODEL=qwen-vl-max  # Stage 2 过滤模型
DASHSCOPE_API_KEY=sk-xxx     # DashScope 密钥（AI 图像生成）
OMNIPARSER_DEVICE=cuda       # OmniParser 设备
```

---

## 3. Stage 1: OmniParser 粗检测

### 3.1 技术栈

- **YOLO**: 图标/按钮检测
- **PaddleOCR**: 文字识别
- **Florence2**: 图标描述生成

### 3.2 输出格式 (UI-JSON)

```json
{
  "metadata": {
    "source": "screenshot.jpg",
    "extractionMethod": "OmniParser",
    "resolution": {"width": 1080, "height": 2400}
  },
  "components": [
    {
      "index": 0,
      "class": "TextView",
      "bounds": {"x": 100, "y": 200, "width": 200, "height": 50},
      "text": "购买火车票",
      "clickable": true
    }
  ],
  "componentCount": 57
}
```

### 3.3 实现代码

```python
# omni_extractor.py
from omni_inference import OmniParser

parser = OmniParser(device='cuda')
results = parser.parse(image_path)

# 转换为 UI-JSON 格式
ui_json = omni_to_ui_json(results)
```

---

## 4. Stage 2: VLM 语义过滤

### 4.1 设计目标

解决 OmniParser 的过度检测问题：
- 海报/Banner 内的文字被单独检测
- 同一按钮的图标和文字分开检测
- 噪声检测和重复检测

### 4.2 核心提示词设计

```python
SEMANTIC_FILTER_PROMPT = """你是一个 UI 结构分析专家。

## 任务流程

### 第一步：分析页面结构

首先，仔细观察截图，识别页面的**功能分区**。常见的分区包括：
- 状态栏（时间、信号、电池）
- 导航栏（返回按钮、标题、操作按钮）
- 广告横幅/Banner
- 功能入口区（Tab切换、快捷功能）
- 主内容区（表单、卡片、列表）
- 底部导航栏

### 第二步：处理检测结果

1. **合并规则**：
   - 只合并**同一个独立UI组件内部**的检测框
   - 广告横幅/Banner 内的文字可以合并为一个 ImageView
   - **不要跨分区合并**！

2. **保留规则**：
   - 独立的按钮、输入框、标签页应该保留
   - 表单内的每个字段应该独立保留

3. **删除规则**：
   - 明显的重复检测
   - 无意义的噪声检测

## 输出格式

```json
{
  "page_analysis": {
    "app_type": "App类型描述",
    "regions": [
      {"name": "状态栏", "description": "顶部状态信息"},
      {"name": "Banner广告", "description": "..."}
    ]
  },
  "operations": [
    {
      "action": "merge",
      "indices": [1, 2, 3],
      "target_class": "ImageView",
      "target_text": "合并后的描述",
      "reason": "这些属于同一个Banner广告内的文字"
    },
    {
      "action": "keep",
      "indices": [10, 11, 12],
      "reason": "这些是表单内独立的输入组件"
    },
    {
      "action": "delete",
      "indices": [5, 6],
      "reason": "重复检测"
    }
  ]
}
```

## 关键原则

1. **粒度适中**：不要过度合并！保留用户可交互的独立组件
2. **尊重功能边界**：不同功能分区的组件不能合并
3. **所有原始组件的 index 必须出现在某个操作中**
"""
```

### 4.3 处理流程

```python
# omni_vlm_fusion.py
def omni_vlm_fusion(screenshot_path, api_key, model='qwen-vl-max'):
    # 1. OmniParser 粗检测
    raw_components = omni_to_ui_json(screenshot_path)

    # 2. 构建 VLM 请求
    prompt = SEMANTIC_FILTER_PROMPT + f"\n\n检测结果:\n{json.dumps(raw_components)}"

    # 3. 调用 VLM
    response = call_vlm(prompt, screenshot_path, model)

    # 4. 应用操作指令
    operations = response['operations']
    filtered = apply_operations(raw_components, operations)

    # 5. 验证文本分配（修复 index 偏移问题）
    filtered = validate_and_fix_text_assignments(filtered, raw_components)

    return filtered
```

---

## 5. Stage 3: 异常场景渲染

### 5.1 模式一: dialog (弹窗覆盖)

#### 5.1.1 场景识别规则

```python
SCENE_PATTERNS = {
    'ticket': {
        'keywords': ['火车票', '机票', '车票', '航班', '余票', '12306', '携程'],
        'dialog_types': ['no_ticket', 'price_change', 'grab_failed', 'queue_timeout']
    },
    'ecommerce': {
        'keywords': ['购物车', '商品', '价格', '淘宝', '京东', '拼多多'],
        'dialog_types': ['out_of_stock', 'coupon_popup', 'flash_sale', 'recommend']
    },
    'social': {
        'keywords': ['好友', '消息', '朋友圈', '微信', '微博'],
        'dialog_types': ['friend_request', 'privacy_alert', 'message_notify']
    },
    'video': {
        'keywords': ['视频', '播放', 'VIP', '会员', '抖音', 'B站', '优酷'],
        'dialog_types': ['vip_prompt', 'ad_popup', 'copyright_notice']
    },
    'finance': {
        'keywords': ['余额', '支付', '转账', '银行卡', '支付宝', '微信支付'],
        'dialog_types': ['payment_failed', 'balance_insufficient', 'security_verify']
    },
    'network': {
        'keywords': ['网络', '加载', '刷新', '连接', '超时'],
        'dialog_types': ['network_error', 'timeout', 'server_error']
    }
}
```

#### 5.1.2 弹窗内容模板

```python
DIALOG_TEMPLATES = {
    'no_ticket': {
        'title': '余票不足',
        'messages': [
            '非常抱歉，您选择的车次余票已售罄',
            '当前班次已无余票，建议选择其他时间',
            '该航班经济舱已售罄，是否查看其他舱位？'
        ],
        'style': 'warning',
        'buttons': ['查看其他', '取消'],
        'icon': 'warning'
    },
    'coupon_popup': {
        'title': '专属优惠券',
        'messages': [
            '恭喜获得 ¥50 优惠券',
            '限时福利：满100减20',
            '新人专享：首单立减30元'
        ],
        'style': 'success',
        'buttons': ['立即领取', '稍后再说'],
        'icon': 'coupon',
        'is_ad': True
    },
    # ... 更多模板
}
```

#### 5.1.3 Meta 驱动生成

**meta.json 结构**:

```json
{
  "category": "dialog_blocking",
  "description": "弹窗覆盖UI - 用于生成各类遮挡弹窗异常",
  "samples": {
    "弹出广告.jpg": {
      "anomaly_type": "reward_badge_dialog",
      "anomaly_description": "中央弹出勋章奖励弹窗",
      "visual_features": {
        "app_style": "华为花粉俱乐部",
        "primary_color": "#C8A882",
        "background": "米白色渐变 #FAF6F0",
        "dialog_position": "center",
        "dialog_size_ratio": {"width": 0.85, "height": 0.55},
        "overlay_enabled": true,
        "overlay_opacity": 0.6,
        "close_button_position": "bottom-center",
        "close_button_style": "gray_circle_x",
        "main_button_text": "立即查看",
        "title_text": "恭喜您获得勋章"
      },
      "generation_template": {
        "instruction": "生成用户成就勋章奖励弹窗",
        "patch_operations": [...],
        "key_points": [
          "居中卡片式弹窗",
          "底部中央关闭按钮",
          "金色圆形勋章图标"
        ]
      }
    }
  }
}
```

#### 5.1.4 VLM 内容生成提示词

```python
CONTENT_GENERATION_PROMPT = """分析这张移动App截图，根据页面内容生成语义相关的弹窗文案。

## 任务
为截图中的 {app_style} 页面生成一个 {anomaly_type} 类型的弹窗内容。

## 输出格式
```json
{
  "title": "弹窗标题",
  "message": "弹窗正文内容",
  "button_primary": "主按钮文字",
  "button_secondary": "次按钮文字（可选）"
}
```

## 要求
1. 内容必须与当前页面语义相关
2. 使用自然的中文表达
3. 符合 {app_style} 的风格调性
"""
```

#### 5.1.5 渲染方式

| 方式 | 实现 | 适用场景 |
|------|------|----------|
| PIL 绘制 | `generate_dialog_pil()` | 简单弹窗、文字清晰度要求高 |
| AI 生成 | `generate_image_dashscope()` | 复杂视觉效果、图片内容 |
| 混合模式 | AI 生成 + PIL 文字叠加 | 高质量 + 清晰文字 |

---

### 5.2 模式二: area_loading (区域加载)

#### 5.2.1 实现流程

```python
# area_loading_renderer.py
class AreaLoadingRenderer:
    def render_area_loading(self, screenshot, component, anomaly_type):
        # 1. 获取组件边界
        bounds = component['bounds']

        # 2. 创建加载图标（AI 生成或参考图风格迁移）
        loading_icon = self._generate_loading_icon(anomaly_type)

        # 3. 计算放置位置（组件中心）
        center_x = bounds['x'] + bounds['width'] // 2
        center_y = bounds['y'] + bounds['height'] // 2

        # 4. 添加半透明遮罩（可选）
        if add_dimming:
            screenshot = self._add_dimming(screenshot, bounds)

        # 5. 叠加加载图标
        result = self._overlay_icon(screenshot, loading_icon, center_x, center_y)

        return result
```

---

### 5.3 模式三: content_duplicate (内容重复)

#### 5.3.1 VLM 风格提取提示词

```python
STYLE_EXTRACTION_PROMPT = """分析这张移动App截图中底部浮层/弹出面板的视觉风格。

请仔细观察并提取以下样式参数，返回JSON格式：
{
    "background_color": "浮层背景色 #hex格式",
    "primary_color": "主色调/选中态颜色 #hex格式",
    "text_color": "主要文字颜色 #hex格式",
    "secondary_text_color": "次要文字颜色 #hex格式",
    "grid_columns": 网格列数(整数),
    "cell_border_radius": 单元格圆角大小(整数像素),
    "cell_background": "普通单元格背景色 #hex格式",
    "selected_background": "选中单元格背景色 #hex格式",
    "has_vip_badge": 是否有VIP/会员标签(true/false),
    "vip_badge_color": "VIP标签背景色 #hex格式",
    "cell_height": 单元格高度估计(整数像素),
    "cell_margin": 单元格间距估计(整数像素),
    "title_visible": 是否显示标题栏(true/false),
    "close_button_visible": 是否有关闭按钮(true/false),
    "close_button_position": "关闭按钮位置",
    "overlay_opacity": 遮罩透明度(0-1的小数)
}

只返回JSON，不要其他内容。
"""
```

#### 5.3.2 实现流程

```python
# content_duplicate_renderer.py
class ContentDuplicateRenderer:
    def render_content_duplicate(self, screenshot, ui_json, instruction, meta_features, reference_path):
        # 1. 查找目标组件（如"选集"、"剧集"）
        component = self.find_duplicatable_component(ui_json, instruction)

        # 2. 分析参考图风格（VLM）
        reference_style = self._analyze_reference_style(reference_path)

        # 3. 分析目标组件内容（VLM）
        component_analysis = self._analyze_component_content(screenshot_path, component)

        # 4. 生成扩展视图（PIL + 风格参数）
        expanded_content = self._generate_expanded_content_pil(
            component_analysis,
            meta_features,
            reference_style=reference_style
        )

        # 5. 创建底部浮层
        sheet_image, sheet_x, sheet_y = self._create_bottom_sheet(
            expanded_content, meta_features, screen_width, screen_height
        )

        # 6. 合成图像（遮罩只覆盖浮层上方）
        result = self._composite_with_overlay(screenshot, sheet_image, sheet_x, sheet_y)

        return result
```

#### 5.3.3 关键实现：风格迁移

```python
def _generate_expanded_content_pil(self, component_analysis, meta_features, reference_style=None):
    """
    PIL 程序化绘制（使用 VLM 提取的风格参数）

    风格来源优先级：reference_style > style_hints > meta_features > 默认值
    """
    # 合并风格参数
    style = component_analysis.get('style_hints', {})
    if reference_style:
        style = {**style, **reference_style}

    # 提取绘制参数
    bg_color = self._parse_color(style.get('background_color', '#2A2A2A'))
    primary_rgb = self._parse_color(style.get('primary_color', '#FF6600'))
    grid_cols = style.get('grid_columns', 6)
    cell_radius = style.get('cell_border_radius', 8)
    has_vip = style.get('has_vip_badge', True)
    vip_color = self._parse_color(style.get('vip_badge_color', '#B4964F'))

    # 绘制网格
    self._draw_episode_grid_styled(
        draw, img, items,
        primary_rgb=primary_rgb,
        grid_cols=grid_cols,
        cell_radius=cell_radius,
        has_vip=has_vip,
        vip_color=vip_color
    )
```

---

## 6. 输出文件说明

每次运行生成以下文件：

| 文件 | 说明 |
|------|------|
| `*_stage1_omni_raw_*.json` | OmniParser 原始检测结果 |
| `*_stage1_annotated_*.png` | 检测结果可视化 |
| `*_stage2_filtered_*.json` | VLM 过滤后的 UI-JSON |
| `*_stage2_annotated_*.png` | 过滤后可视化 |
| `*_final_*.png` | **最终异常截图** |
| `*_pipeline_meta_*.json` | 流水线元数据 |

---

## 7. 使用示例

### 7.1 基础用法

```bash
# 生成网络超时弹窗
python run_pipeline.py \
  --screenshot ./test.jpg \
  --instruction "模拟网络超时弹窗"
```

### 7.2 Meta 驱动生成（推荐）

```bash
# 使用 GT 模板生成高质量弹窗
python run_pipeline.py \
  --screenshot ./test.jpg \
  --instruction "生成优惠券弹窗" \
  --gt-category "弹窗覆盖原UI" \
  --gt-sample "商品下方存在遮挡.jpg"
```

### 7.3 内容重复异常

```bash
# 生成选集列表重复
python run_pipeline.py \
  --screenshot ./腾讯视频.jpg \
  --instruction "剧集控件处显示重复列表" \
  --anomaly-mode content_duplicate \
  --gt-category "内容歧义、重复" \
  --gt-sample "部分信息重复.jpg"
```

### 7.4 区域加载异常

```bash
# 生成列表加载中状态
python run_pipeline.py \
  --screenshot ./test.jpg \
  --instruction "模拟列表加载超时" \
  --anomaly-mode area_loading \
  --target-component 5
```

---

## 8. 核心模块依赖

```
scripts/
├── run_pipeline.py              # 入口
├── omni_extractor.py            # Stage 1
├── omni_vlm_fusion.py           # Stage 2
├── patch_renderer.py            # Stage 3 (dialog)
├── area_loading_renderer.py     # Stage 3 (area_loading)
├── content_duplicate_renderer.py # Stage 3 (content_duplicate)
└── utils/
    ├── semantic_dialog_generator.py  # 弹窗生成核心
    ├── meta_loader.py               # GT 元数据加载
    ├── component_position_resolver.py # 组件定位
    └── reference_analyzer.py         # 参考图风格分析
```

---

## 9. 性能指标

| 阶段 | 耗时 | 主要成本 |
|------|------|--------|
| Stage 1 (OmniParser) | 10-30s | YOLO + OCR 推理 |
| Stage 2 (VLM 过滤) | 30-60s | API 调用 |
| Stage 3 (渲染) | 20-40s | AI 图像生成 / PIL 绘制 |
| **总计** | **60-130s** | - |

---

## 10. 扩展指南

### 10.1 添加新的异常模式

1. 创建新渲染器 `scripts/xxx_renderer.py`
2. 在 `run_pipeline.py` 添加参数选项
3. 添加对应的 Stage 3 分支逻辑
4. 创建 `data/gt_templates/新类别/meta.json`

### 10.2 添加新的弹窗模板

编辑 `semantic_dialog_generator.py`:
1. 在 `SCENE_PATTERNS` 添加场景识别规则
2. 在 `DIALOG_TEMPLATES` 添加弹窗模板

### 10.3 自定义 VLM 提示词

各阶段提示词位置：
- Stage 2 过滤: `omni_vlm_fusion.py` - `SEMANTIC_FILTER_PROMPT`
- 弹窗内容生成: `semantic_dialog_generator.py` - `generate_content_for_target_page()`
- 风格提取: `content_duplicate_renderer.py` - `_analyze_reference_style()`

---

## 附录 A: GT 模板类别

| 类别 | 样本数 | 典型场景 |
|------|--------|----------|
| 弹窗覆盖原UI | 7 | 广告弹窗、权限请求、优惠券、教程引导 |
| 内容歧义、重复 | 1 | 选集列表重复显示 |
| loading_timeout | 1 | 白屏无内容 |

## 附录 B: 支持的组件类型

Stage 2 VLM 过滤支持的组件类型：

- `StatusBar` - 状态栏
- `NavigationBar` - 导航栏
- `TextView` - 文本视图
- `Button` - 按钮
- `ImageView` - 图片视图
- `ImageButton` - 图片按钮
- `Card` - 卡片
- `TabBar` / `TabItem` - 标签栏
- `SearchBar` - 搜索栏
- `Dialog` - 弹窗
- `Avatar` - 头像
- `ListItem` - 列表项
- `InputField` - 输入框
